---
title: "Disturbance"
author: "Sylvain Schmitt sylvain.schmitt@agroparistech.fr"
date: '`r Sys.Date()`'
output:
  html_document: default
  pdf_document: default
  word_document: default
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
---

```{r config, message=FALSE, warning=FALSE, include=FALSE}
library(knitr)
library(parallel)
cores <- detectCores() - 1
# devtools::install_github('sylvainschmitt/RconTroll')
library(TROLL)
library(RconTroll)
library(ggplot2)
library(cowplot)
library(hypervolume)
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 8, fig.width = 8,
    cache = T, cache.lazy = F)
```

Built with `RconTroll` package version `r packageVersion('RconTroll')` available at https://gitlab.com/sylvain.schmitt/RconTroll and `TROLL` package version `r packageVersion('TROLL')` available at https://gitlab.com/sylvain.schmitt/TROLL with `r R.Version()$version.string` environment.

# Design of experiment

## Space of experiments

```{r Sample, include=FALSE}
# Init
path <- '~/Documents/ECOFOG/Results/disturbance/'
set.seed(42)
n <- 10^2
dist <- 0:3*0.25
rich <- 3^(1:4)
# # Coms
# species <- read.table('~/Documents/ECOFOG/TROLL/inst/extdata/species.txt', header=TRUE, dec=".", sep="", row.names = 1)
# species <- species[c('LMA', 'wsg', 'hmax', 'dmax')]
# proba <- ks::kde(scale(species), eval.points = scale(species))$estimate
# proba <- 1/proba
# coms <- lapply(as.list(rich), function(r)
#   replicate(n, species[sample(row.names(species), r, F, proba),],
#             simplify = F))
# names(coms) <- rich ; rm(proba)
# # Dists
# CWM <- lapply(coms, function(x) do.call('rbind', lapply(x, function(y) apply(y,2, mean))))
# Centroids <- lapply(CWM, function(x) apply(x, 2, mean))
# Dist <- data.frame(mapply(function(x,y) apply(x, 1, function(z) sqrt(sum((z - y)^2))), x = CWM, y = Centroids))
# names(Dist) <- paste0('dist.', rich) ; rm(CWM, Centroids)
# # HV
# bd <- estimate_bandwidth(scale(species))
# cl <- makeCluster(cores)
# clusterExport(cl, list('coms', 'bd'))
# HV <- parLapply(cl, coms, function(x)  lapply(x, function(y)
#   try(hypervolume::get_volume(
#     hypervolume::hypervolume(
#       scale(y), bandwidth = bd, verbose = F, warnings = F)))))
# stopCluster(cl) ; rm(cl)
# HV <- data.frame(do.call('cbind', lapply(HV, unlist)))
# names(HV) <- paste0('HV.', rich) ; rm(bd)
# # Sample
# i <- 1:n
# Sample <- cbind(i, Dist, HV)
# Sample <- lapply(as.list(rich), function(r) Sample[grep(r, names(Sample))])
# names(Sample) <- rich
# Sample <- lapply(Sample, function(x) x[x[,1] < sd(x[,1]),])
# Sample <- lapply(Sample, function(x) {x$num <- row.names(x) ; return(x)})
# Scale <- lapply(Sample, function(x) seq(from = min(x[,2]), max(x[,2]), length.out = 10))
# Sample <- mapply(function(x,y) do.call('rbind', sapply(y, function(z)
#   x[which.min(abs(x[,2] - z)) ,], simplify = F)),  x = Sample, y = Scale, SIMPLIFY = F)
# Sel <- lapply(Sample, function(x) x$num)
# Sel <- mapply(function(x,y) x[as.numeric(y)], x = coms, y = Sel, SIMPLIFY = F)
# Sel <- lapply(Sel, function(x) lapply(x, row.names))
# names(Sel) <- rich ; rm(i, Scale, HV, Dist)
# save(Sel, Sample, file = file.path(path, 'SpeciesSel.Rdata'))
load(file.path(path, 'SpeciesSel.Rdata'))
```

The space of experiments encompass following axes (with their abbreviations and values) :

- **Disturbance:** $dist \in \left\{ `r paste(dist)` \right\}$
- **Richness:** $rich \in \left\{ `r paste(rich)` \right\}$
- **Community hypervolume:** $hv$

Community hypervolume will depend on richness (higher richness implying less choices). So we can already measure possible community hypervolumes depending on the level of richness for a given community mean. To do that we sampled $`r n`$ communities for each richness level. Sampling was done by attributing to each species a probability to be pick inverse of its densities in the 4-dimensional functional trait space computed with R package `ks`. Once random communities sampled, we measured each community mean and calculated community euclidean distance to the metacommunity mean. We wanted to control ecosystem functional composition with community mean. In order to do that, we decided to keep only simulated community for which community euclidean distance to metacommunity mean was smaller than the standard deviation of euclidean distances of all simulated communities. Once potential communities designated for each level of richness, we defined for each leavel of richness 10 equidistant hypervolumes size and we kept the closest community of each hypervolume level.

We obtained the followin designed of experiment (DOE) without disturbance (to replicate for each 4 levels of disturbance):

```{r DOE}
data <- data.frame(
  Richness = as.vector(mapply(function(x,y) rep(x,y), x = 3^(1:4), y = head(unlist(lapply(Sel, length)),4))),
  Hypervolume = unlist(lapply(Sample, function(x) x[,2])),
  Dist = unlist(lapply(Sample, function(x) x[,1])))
row.names(data) <- 1:dim(data)[1]
kable(data)
```

## Pre-disturbance simulations

```{r Parameters}
# path <- '~/Documents/ECOFOG/Results/disturbance/'
# dist <- 0:3*0.25
# rich <- 3^(1:4)
# load(file.path(path, 'SpeciesSel.Rdata')) ; rm(Sample) # Species Selection
# seedrain <- 50 # Seedtrain constant to fix
# ncores <- 15
```

```{r Init}
# dir.create(file.path(path, 'maturity'))
# sim <- as.vector(sapply(rich, function(r) paste(r, 1:10, sep = '.')))
# invisible(sapply(sim, function(s) dir.create(file.path(path, 'maturity', s))))
# Sel <- unlist(Sel, recursive = F)
# names(Sel) <- sim
# species <- read.table('~/Documents/ECOFOG/TROLL/inst/extdata/species.txt', header=TRUE, dec=".", sep="")
# Sel <- lapply(Sel, function(com){
#   com <- species[which(species$Name %in% com),]
#   com$Freg <- 1/dim(com)[1]
#   return(com)
# })
# invisible(sapply(sim, function(s){
#   init(path = file.path(path, 'maturity'),
#        input = paste0(s, '.txt'),
#        species = Sel[[s]],
#        numesp = dim(Sel[[s]])[1],
#        nbiter = 12*500, disturb_iter = 12*500+1,
#        seedrain = seedrain)
# }))
```


```{r Bash}
# if('maturity.sh' %in% list.files(file.path(path, 'maturity')))
#    unlink(file.path(path, 'maturity', 'maturity.sh'))
# bash <- file(file.path(path, 'maturity', 'maturity.sh'), open = 'a')
# cat(' #!/bin/bash  \n\n', file = bash, append = TRUE)
# cat(' echo "maturity forest parrallel modelling in TROLL" \n\n', file = bash, append = TRUE)
# for(i in seq_len(length(sim))){
#   command <- paste0('./TROLL.out',
#                     ' -i"', sim[i], '.txt"',
#                     ' -o./', sim[i], '/', sim[i], ' &\n')
#   cat(command, file = bash, append = TRUE)
#   if(i %/% ncores == i/ncores)
#   cat('wait\n', file = bash, append = TRUE)
# }
# cat('wait\n', file = bash, append = TRUE)
# cat(' echo "TROLL all jobs done"  \n\n', file = bash, append = TRUE)
# close(bash)
```




# References