---
title: "Rotten"
author: "Sylvain Schmitt sylvain.schmitt@agroparistech.fr"
date: '`r Sys.Date()`'
output:
  html_document: 
    theme: journal
    toc: yes
    toc_depth: 5
    toc_float: yes
  pdf_document: default
  word_document: default
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
---

```{r config, message=FALSE, warning=FALSE, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(parallel)
library(TROLL)
library(reshape2)
library(ggplot2)
library(cowplot)
library(entropart)
library(plotly)
library(rstan)
library(bayesplot)
library(rstanarm)
library(readr)
library(dplyr)
library(randomForest)
library(GGally)
library(BIOMASS)
library(RconTroll)
cores <- detectCores()
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
    cache = T, cache.lazy = F)
```

# Introduction

In order to simulate sylviculture with TROLL we need to implement a new sylviculture module inside TROLL model code. A first litterature review was completed by an interview with Laurent Descroix of the Office Nationale des ForÃªts. We discovered that rotten trees were not random and seemed to depend both on tree species and diameter. This document presents modelling of relation between rotten trees and their species and diameter.

In fact we have two different questions:

- Predict if a tree will be probed as rotten (models **M**, see [rotten 2](rotten2.html)) 
- Predict how much of tree volume is rotten (models **N**, see [rotten 3](rotten3.html))

First all **M** model can be written as follow:
$$Rotten_n \sim \mathcal{B}(\theta_n), ~~n \in [1,N_{=3816}] ~~ p \in [1, P_{=8}], ~~ s \in [1, S_{=43}]$$
Secondly, all **N** models depend on a latent variable being the volume of rotten wood $V_r$. We can assume that all trees are growing depending on species $s$ and plot $p$ fertility and are supposed to have a full healthy volume $V_h$ for a given diameter $dbh$. Then the final volume of softwood $V_f$ product will be the difference between the theoritical full healthy volume $V_h$ and the actual volume of rotten wood $V_r$:
$$ V_f = V_h - V_r = f(dbh, sp) - V_r$$
$$ V_r = V_f - f(dbh, sp)$$
$$V_r \sim \mathcal{N}(\mu, \sigma)$$
$$n \in [1,N_{=3268}] ~~ p \in [1, P_{=8}], ~~ s \in [1, S_{=43}]$$

We retained following models :

Table 2: Models summary.
```{r mtab}
mtab <- data.frame(
  M = c('$M_{s,p}$', 'N?'),
  Model = c(
    "$logit(\\theta_n) = {\\beta_0}_p + {\\beta_1}_s + \\beta_3*dbh_n$",
    "$\\mu = V_f - ?$"
    )
  )
mtab <- apply(mtab, 2, as.character)
kable(mtab)
row.names(mtab) <- c('Ms.p', 'N?')
```

# Probed rotten (M)

Based on complexity (number of parameters), convergence and likelihood we selected model $M_{s,p}$ (see see [rotten 2](rotten2.html)):
$$Rotten_n \sim \mathcal{B}(\theta_n), ~~n \in [1,N_{=3816}] ~~ p \in [1, P_{=8}], ~~ s \in [1, S_{=43}]$$
$$logit(\theta_n) = {\beta_0}_p + {\beta_1}_s + \beta_3*dbh_n$$

```{r M pred, fig.height=12, fig.width=12}
# beta <- as.matrix(fits$fit11$full)[which.max(as.matrix(fits$fit11$full)[,'lp__']),c('beta_1', 'beta_2', 'beta_3')]
# fit <- fits$fit10$full
# LLpred <- function(LMA, Nmass, wsg, LMAmax, Nmax, wsgmax, beta1, beta2, beta3, sigma){
#   mu <- beta1*(LMA/LMAmax) - beta2*(Nmass/Nmax) + beta3*(wsg/wsgmax)
#   rlnorm(1, mu, sigma)
# }
# pred <- apply(as.matrix(fit), 1, function(x)
#   sapply(seq_len(dim(data)[1]), function(i)
#       LLpred(data$LMA[i], data$Nmass[i], data$wsg[i], LMAmax, Nmax, wsgmax, x['beta_1'], x['beta_2'], x['beta_3'], x['sigma'])
#     ))
# pred <- data.frame(t(apply(pred, 1, function(x) quantile(x, probs = c(0.05, 0.95)))))
# names(pred) <- c('5%', '95%')
# pred$mean <- exp((beta[1]*(data$LMA/LMAmax) - beta[2]*(data$Nmass/Nmax) + beta[3]*(data$wsg/wsgmax)))
# pred$LMA <- data$LMA
# pred$Nmass <- data$Nmass
# pred$wsg <- data$wsg
# g <- ggplot(data, aes(x = LMA, y = LL)) +
#   geom_ribbon(aes(x = pred$LMA, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
#   geom_line(aes(x = pred$LMA, y = pred$`5%`, color = '5%'), linetype = 2) +
#   geom_line(aes(x = pred$LMA, y = pred$`95%`, color = '95%'), linetype = 2) +
#   geom_line(aes(x = pred$LMA, y = pred$mean, color = 'mean'), linetype = 2) +
#   geom_point() +
#   theme_bw() +
#   xlab('Leaf mass per area (LMA in g/m2)') +
#   ylab('Leaf lifespan (LL in months)') +
#   scale_color_manual(name = 'Model',
#                      values = c('5%' = 'black',
#                                 '95%' = 'black',
#                                 'mean' = 'red'))
# h <- ggplot(data, aes(x = Nmass, y = LL)) +
#   geom_ribbon(aes(x = pred$Nmass, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
#   geom_line(aes(x = pred$Nmass, y = pred$`5%`, color = '5%'), linetype = 2) +
#   geom_line(aes(x = pred$Nmass, y = pred$`95%`, color = '95%'), linetype = 2) +
#   geom_line(aes(x = pred$Nmass, y = pred$mean, color = 'mean'), linetype = 2) +
#   geom_point() +
#   theme_bw() +
#   xlab('Leaf nitrogen content (Nmass in %)') +
#   ylab('Leaf lifespan (LL in months)') +
#   scale_color_manual(name = 'Model',
#                      values = c('5%' = 'black',
#                                 '95%' = 'black',
#                                 'mean' = 'red'))
# f <- ggplot(data, aes(x = wsg, y = LL)) +
#   geom_ribbon(aes(x = pred$wsg, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
#   geom_line(aes(x = pred$wsg, y = pred$`5%`, color = '5%'), linetype = 2) +
#   geom_line(aes(x = pred$wsg, y = pred$`95%`, color = '95%'), linetype = 2) +
#   geom_line(aes(x = pred$wsg, y = pred$mean, color = 'mean'), linetype = 2) +
#   geom_point() +
#   theme_bw() +
#   xlab('Leaf nitrogen content (Nmass in %)') +
#   ylab('Leaf lifespan (LL in months)') +
#   scale_color_manual(name = 'Model',
#                      values = c('5%' = 'black',
#                                 '95%' = 'black',
#                                 'mean' = 'red'))
# plot_grid(g, h, f, labels = c('LMA', 'Nmass', 'wsg'))
# p <- subplot(ggplotly(g, width = 800, height = 400), ggplotly(h, width = 800, height = 400), shareY = T, shareX = F, titleX = T)
# chart_link <- plotly_POST(p, filename = "LL1")
# save(chart_link,
     # file = '~/Documents/ECOFOG/TROLL/inst/doc/LL_models/LL1.Rdata')
# load('~/Documents/ECOFOG/TROLL/inst/doc/LL_models/LL1.Rdata')
# chart_link

# Rotten volume (N)

# References
