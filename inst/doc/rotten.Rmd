---
title: "Rotten"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc())
library(flexdashboard)
library(knitr)
library(parallel)
library(TROLL)
library(RconTroll)
library(BIOMASS)
library(reshape2)
library(ggplot2)
library(cowplot)
library(entropart)
library(plotly)
library(rstan)
library(bayesplot)
library(rstanarm)
library(readr)
library(GGally)
library(dplyr)
cores <- detectCores()
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
    cache = T, cache.lazy = F)
mpath <- "~/Documents/ECOFOG/TROLL/inst/doc/rotten_models"
rstan_options(auto_write = TRUE)
options(mc.cores = detectCores())
```

Intro
==================

Issue {data-width=200}
-------------------------------------

In order to simulate sylviculture with TROLL we need to implement a new sylviculture module inside TROLL model code. A first litterature review was completed by an interview with Laurent Descroix of the Office Nationale des ForÃªts. We discovered that rotten trees were not random and seemed to depend both on tree species and diameter. This document presents modelling of relation between rotten trees and their species and diameter.

```{r data, include=FALSE}
data <- read_csv("~/Documents/ECOFOG/TROLL/inst/extdata/Rotten/rotten_data.csv")
data <- data[c('num', 'Parcelle', 'up', 'ess', 'abattu', 'tout BE', 'sonde_creux', 'sonde_creux abatt', 'sonde_creux_refus', 'DBH_desi', 'V_Est', 'vol_BO')]
names(data) <- c('id', 'plot', 'subplot', 'spCode', 'logged', 'rotten_full', 'probed_rotten', 'probed_rotten_logged', 'probed_rotten_refused', 'dbhest', 'Vest', 'Vbo')
species <- read_csv("~/Documents/ECOFOG/TROLL/inst/extdata/Rotten/rotten_species.csv")[-1,]
species <- species[c("Code \nEssence" , "Nom \nscientifique")]
names(species) <- c('spCode', 'species')
species$wsg <- apply(do.call('rbind', lapply(strsplit(species$species, ' ', fixed = T), function(x) x[1:2])),
                   1, function(x) getWoodDensity(x[1], x[2], region = 'SouthAmericaTrop')$meanWD)
data <- data.frame(left_join(data, species)) ; rm(species)
data <- data[-which(is.nan(data$wsg)),]
data$sp <- apply(data[c('plot', 'species')], 1 , paste, collapse = '.')
```

In fact we have two different questions:

- Predict if a tree will be probed as rotten (models **M**)
- Predict how much of tree volume is rotten (models **N**)

First all **M** model can be written as follow:

$$Rotten_n \sim \mathcal{B}(\theta_n), ~~n \in [1,N_{=3816}] ~~ p \in [1, P_{=8}], ~~ s \in [1, S_{=43}]$$

Table 2: Models summary.
```{r mtab}
mtab <- data.frame(
  m = c(paste0('M', 1:7)),
  model = c(
    "$logit(\\theta_n) = {\\beta_0} + {\\beta_1}_p + {\\beta_2}_s +{\\beta_3}*dbh_n, ~~ {\\beta_1}_p \\sim \\mathcal{N}(\\beta_1, \\sigma_p), ~~~~{\\beta_2}_s \\sim \\mathcal{N}(\\beta_2, \\sigma_2)$",
    "$logit(\\theta_n) = {\\beta_0}_p + {\\beta_1}_p*wsg_n +{\\beta_2}_p*dbh_n, ~~ {\\beta_k}_p \\sim \\mathcal{N}(\\beta_k, \\sigma_k)$",
    "$logit(\\theta_n) = {\\beta_1}_p + {\\beta_2}_s +{\\beta_3}*dbh_n, ~~ {\\beta_1}_p \\sim \\mathcal{N}(\\beta_1, \\sigma_p), ~~~~{\\beta_2}_s \\sim \\mathcal{N}(\\beta_2, \\sigma_2)$",
    "$logit(\\theta_n) = {\\beta_0}_{sp} + {\\beta_1}_{sp} +{\\beta_2}_{sp}*dbh_n, ~~ {\\beta_k}_{sp} \\sim \\mathcal{N}(\\beta_k, \\sigma_k)$",
    "$logit(\\theta_n) = {\\beta_1}_{sp} +{\\beta_2}_{sp}*dbh_n, ~~ {\\beta_k}_{sp} \\sim \\mathcal{N}(\\beta_k, \\sigma_k)$",
    "$logit(\\theta_n) = {\\beta_2}_{sp}*dbh_n, ~~ {\\beta_k}_{sp} \\sim \\mathcal{N}(\\beta_k, \\sigma_k)$",
    "$logit(\\theta_n) = {\\beta_1}_p*wsg_n +{\\beta_2}_p*dbh_n, ~~ {\\beta_k}_p \\sim \\mathcal{N}(\\beta_k, \\sigma_k)$"
    ),
  code = c('$M_{s+p}$', '$M_{p+wsg}$', '$M_{s+p-\\beta_0}$', '$M_{sp}$', '$M_{sp-\\beta_0}$',
           '$M_{sp-\\beta_0-\\beta_1}$', '$M_{p+wsg-\\beta_0}$'))
mtab <- apply(mtab, 2, as.character)
kable(mtab)
```

We tested models M1 to MX detailed in following tabs to find the better trade-off between:

1. Complexity (and number of parameters)
2. Convergence
3. Likelihood
4. Prediction quality with Root Mean Square Error of Prediction (RMSEP)

RMSEP was computed by fitting a model without a plot and evaluating it with the same plot. RMSEP in results are mean RMSEP for each plot. Results are shown for each models in each model tabs and summarized in [Results](#results) tab.

Graph {data-width=200}
-------------------------------------

### Trees probbed rotten and estimated dbh.
```{r data graph}
group_by(data, dbhest) %>%
  summarise_each(funs(mean)) %>%
  ggplot(aes(x = dbhest, y = probed_rotten)) +
  geom_point() +
  xlab('Estimated dbh (cm)') +
  ylab('Probed rotten (%)')
```

```{r functions}
fitgraph <- function(fit){
  pars <- fit@model_pars
  beta <- pars[grep('beta', pars)]
  if(length(grep('sp', beta)) > 0)
    beta <- beta[-grep('sp', beta)]
  if(length(grep('s', beta)) > 0)
     beta <- beta[-grep('s', beta)]
  if(length(grep('p', beta)) > 0)
    beta <- beta[-grep('p', beta)]
  sigma <- pars[grep('sigma', pars)]
  posterior <- as.matrix(fit)
  r <- mcmc_areas(posterior,  pars = c(beta, sigma), prob = 0.8)
  c <- mcmc_trace(posterior,  pars = c(beta, sigma,  'lp__'),
                   facet_args = list(nrow = 2, labeller = label_parsed))
  p <- ggpairs(data.frame(posterior[,beta]))
  return(list(r = r, c = c, p = p))
}
```

`r paste(mtab[1,c(1,3)], collapse = ', ')`
==================

```{r M1, include=FALSE}
# fit <- stan(file = file.path(mpath, 'M1.stan'),
#             data = list(N = dim(data)[1],
#                         P = length(levels(as.factor(data$plot))),
#                         S = length(levels(as.factor(data$species))),
#                         plot = as.integer(as.factor(data$plot)),
#                         species = as.integer(as.factor(data$species)),
#                         dbh = data$dbhest/max(data$dbhtest),
#                         rotten = data$rotten),
#             chains = 1)
# save(fit, file = file.path(mpath, 'M1.Rdata'))
load(file.path(mpath, 'M1.Rdata'))
g <- fitgraph(fit) ; rm(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab[1,1:2], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r r1}
g$r
```

Convergence {data-width=300} 
-------------------------------------

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r c1}
g$c
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r p1}
g$p
```

`r paste(mtab[2,c(1,3)], collapse = ', ')`
==================

```{r M2, include=FALSE}
# fit <- stan(file = file.path(mpath, 'M2.stan'),
#             data = list(N = dim(data)[1],
#                         P = length(levels(as.factor(data$plot))),
#                         plot = as.integer(as.factor(data$plot)),
#                         wsg = data$wsg/max(data$wsg),
#                         dbh = data$dbhest/max(data$dbhest),
#                         rotten = data$rotten),
#             chains = 1)
# save(fit, file = file.path(mpath, 'M2.Rdata'))
load(file.path(mpath, 'M2.Rdata'))
g <- fitgraph(fit) ; rm(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab[2,1:2], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r r2}
g$r
```

Convergence {data-width=300} 
-------------------------------------

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r c2}
g$c
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r p2}
g$p
```

`r paste(mtab[3,c(1,3)], collapse = ', ')`
==================

```{r M3, include=FALSE}
# fit <- stan(file = file.path(mpath, 'M3.stan'),
#             data = list(N = dim(data)[1],
#                         P = length(levels(as.factor(data$plot))),
#                         S = length(levels(as.factor(data$species))),
#                         plot = as.integer(as.factor(data$plot)),
#                         species = as.integer(as.factor(data$species)),
#                         dbh = data$dbhest/max(data$dbhtest),
#                         rotten = data$rotten),
#             chains = 1)
# save(fit, file = file.path(mpath, 'M3.Rdata'))
load(file.path(mpath, 'M3.Rdata'))
g <- fitgraph(fit) ; rm(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab[3,1:2], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r r3}
g$r
```

Convergence {data-width=300} 
-------------------------------------

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r c3}
g$c
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r p3}
g$p
```

`r paste(mtab[4,c(1,3)], collapse = ', ')`
==================

```{r M4, include=FALSE}
# fit <- stan(file = file.path(mpath, 'M4.stan'),
#             data = list(N = dim(data)[1],
#                         SP = length(levels(as.factor(data$sp))),
#                         sp = as.integer(as.factor(data$sp)),
#                         dbh = data$dbhest/max(data$dbhest),
#                         rotten = data$rotten),
#             chains = 1)
# save(fit, file = file.path(mpath, 'M4.Rdata'))
load(file.path(mpath, 'M4.Rdata'))
g <- fitgraph(fit) ; rm(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab[4,1:2], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r r4}
g$r
```

Convergence {data-width=300} 
-------------------------------------

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r c4}
g$c
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r p4}
g$p
```

`r paste(mtab[5,c(1,3)], collapse = ', ')`
==================

```{r M5, include=FALSE}
# fit <- stan(file = file.path(mpath, 'M5.stan'),
#             data = list(N = dim(data)[1],
#                         SP = length(levels(as.factor(data$sp))),
#                         sp = as.integer(as.factor(data$sp)),
#                         dbh = data$dbhest/max(data$dbhest),
#                         rotten = data$rotten),
#             chains = 1)
# save(fit, file = file.path(mpath, 'M5.Rdata'))
load(file.path(mpath, 'M5.Rdata'))
g <- fitgraph(fit) ; rm(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab[5,1:2], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r r5}
g$r
```

Convergence {data-width=300} 
-------------------------------------

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r c5}
g$c
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r p5}
g$p
```

`r paste(mtab[6,c(1,3)], collapse = ', ')`
==================

```{r M6, include=FALSE}
# fit <- stan(file = file.path(mpath, 'M6.stan'),
#             data = list(N = dim(data)[1],
#                         SP = length(levels(as.factor(data$sp))),
#                         sp = as.integer(as.factor(data$sp)),
#                         dbh = data$dbhest/max(data$dbhest),
#                         rotten = data$rotten),
#             chains = 1)
# save(fit, file = file.path(mpath, 'M6.Rdata'))
load(file.path(mpath, 'M6.Rdata'))
g <- fitgraph(fit) ; rm(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab[6,1:2], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r r6}
g$r
```

Convergence {data-width=300} 
-------------------------------------

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r c6}
g$c
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r p6}
g$p
```

`r paste(mtab[7,c(1,3)], collapse = ', ')`
==================

```{r M7, include=FALSE}
# fit <- stan(file = file.path(mpath, 'M7.stan'),
#             data = list(N = dim(data)[1],
#                         P = length(levels(as.factor(data$plot))),
#                         plot = as.integer(as.factor(data$plot)),
#                         wsg = data$wsg/max(data$wsg),
#                         dbh = data$dbhest/max(data$dbhest),
#                         rotten = data$rotten),
#             chains = 1)
# save(fit, file = file.path(mpath, 'M7.Rdata'))
load(file.path(mpath, 'M7.Rdata'))
g <- fitgraph(fit) ; rm(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab[7,1:2], collapse = ': ')`

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r r7}
g$r
```

Convergence {data-width=300} 
-------------------------------------

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r c7}
g$c
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r p7}
g$p
```

Conclusion
==================

> Only few models converged (M2, M6, and M7). Among theim **M2** is the one with the highest maximum likelihood ($ML \sim -920$) and few parameters ($K = 3$). Moreover **M2** have the advantage to use wood specific gravity (wsg) to proxy species factors influence. So we can add any species to the model once we get its wsg.

Column {data-width=200}
-------------------------------------

Column {data-width=600}
-------------------------------------

References
==================

