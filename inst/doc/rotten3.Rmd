---
title: "Rotten volume"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc())
library(flexdashboard)
library(knitr)
library(parallel)
library(TROLL)
library(RconTroll)
library(BIOMASS)
library(reshape2)
library(ggplot2)
library(cowplot)
library(entropart)
library(plotly)
library(rstan)
library(bayesplot)
library(rstanarm)
library(readr)
library(GGally)
library(dplyr)
cores <- detectCores()
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
    cache = T, cache.lazy = F)
mpath <- "~/Documents/ECOFOG/TROLL/inst/doc/rotten_models"
rstan_options(auto_write = TRUE)
options(mc.cores = detectCores())
```

Intro
==================

Issue {data-width=200}
-------------------------------------

In order to simulate sylviculture with TROLL we need to implement a new sylviculture module inside TROLL model code. A first litterature review was completed by an interview with Laurent Descroix of the Office Nationale des ForÃªts. We discovered that rotten trees were not random and seemed to depend both on tree species and diameter. This document presents modelling of relation between rotten trees and their species and diameter.

```{r data, include=FALSE}
data <- read_csv("~/Documents/ECOFOG/TROLL/inst/extdata/Rotten/rotten_data.csv")
data <- data[c('num', 'Parcelle', 'up', 'ess', 'abattu', 'tout BE', 'sonde_creux', 'sonde_creux abatt', 'sonde_creux_refus', 'DBH_desi', 'V_Est', 'vol_BO')]
names(data) <- c('id', 'plot', 'subplot', 'spCode', 'logged', 'rotten_full', 'probed_rotten', 'probed_rotten_logged', 'probed_rotten_refused', 'dbhest', 'Vest', 'Vbo')
data <- subset(data, !is.na(Vbo))
data <- subset(data, Vbo!=0)
data <- data[c('id', 'plot', 'spCode', 'probed_rotten', 'Vbo', 'dbhest')]
species <- read_csv("~/Documents/ECOFOG/TROLL/inst/extdata/Rotten/rotten_species.csv")[-1,]
species <- species[c("Code \nEssence" , "Nom \nscientifique")]
names(species) <- c('spCode', 'species')
data <- data.frame(left_join(data, species)) ; rm(species)
dbhmax <- max(data$dbhest)
data2 <- data[sample.int(dim(data)[1], 500, replace = F),]
```

In fact we have two different questions:

- Predict if a tree will be probed as rotten (models **M**, see [rotten 2](rotten2.html)) 
- Predict how much of tree volume is rotten (models **N**, see [rotten 3](rotten3.html))

Table 2: Models summary.
```{r mtab}
mtab <- data.frame(
  N = c('$N$', '$N_{p}$', '$N_{s}$', '$N_{p,s}$'),
  Model = c(
    "$V_f \\sim \\mathcal{logN} (log[(\\beta*dbh^2)*(1 - Pr*\\rho)], \\sigma)$",
    "$V_f \\sim \\mathcal{logN} (log[((\\beta + \\beta_p)*dbh^2)*(1 - Pr*\\rho)], \\sigma)$",
    "$V_f \\sim \\mathcal{logN} (log[((\\beta + \\beta_s)*dbh^2)*(1 - Pr*\\rho)], \\sigma)$",
    "$V_f \\sim \\mathcal{logN} (log[((\\beta + \\beta_p + \\beta_s)*dbh^2)*(1 - Pr*\\rho)], \\sigma)$"
    )
  )
mtab$N <- as.character(mtab$N)
mtab$Model <- as.character(mtab$Model)
row.names(mtab) <- c('N', 'Np', 'Ns', 'Nps')
kable(mtab, row.names = F)
```

We tested models N detailed in following tabs to find the better trade-off between:

1. Complexity (and number of parameters)
2. Convergence
3. Likelihood

Results are shown for each models in each model tabs and summarized in [Conclusion](#conclusion) tab.

Graph {data-width=200}
-------------------------------------

### Trees estimated dbh and final softwood product.
```{r data graph}
  ggplot(data, aes(x = dbhest, y = Vbo, color = as.factor(probed_rotten), alpha = as.factor(probed_rotten))) + 
  geom_point() + geom_jitter() +
  xlab('Estimated dbh (cm)') +
  ylab('Final softwood product (m3)') +
  scale_alpha_discrete(guide = "none") +
  scale_color_discrete('Probed rotten',
                       labels = c('False', 'True'))
```

```{r functions}
fitgraph <- function(fit, rho = T){
  # pars <- fit@model_pars
  pars <- colnames(as.matrix(fit))
  beta <- pars[grep('beta', pars)]
  if(length(grep('s', beta)) > 0)
     beta <- beta[-grep('s', beta)]
  if(length(grep('p', beta)) > 0)
    beta <- beta[-grep('p', beta)]
  if(rho)
    rho <- pars[grep('rho', pars)]
  if(rho == FALSE)
    rho <- character()
  theta <- pars[grep('theta', pars)]
  if(length(grep('s', theta)) > 0)
     theta <- theta[-grep('s', theta)]
  if(length(grep('p', theta)) > 0)
    theta <- theta[-grep('p', theta)]
  sigma <- pars[grep('sigma', pars)]
  posterior <- as.matrix(fit)
  r <- mcmc_areas(posterior,  pars = c(beta, rho, theta, sigma), prob = 0.8,
                  facet_args = list(labeller = label_parsed))
  c <- mcmc_trace(posterior,  pars = c(beta, rho, theta, sigma,  'lp__'),
                   facet_args = list(nrow = 2, labeller = label_parsed))
  p <- ggpairs(data.frame(posterior[,c(beta, rho, theta)]))
  return(list(r = r, c = c, p = p))
}
```

`r mtab['N',1]`
==================

```{r N, include=FALSE}
# fit <- stan(file = file.path(mpath, 'N.stan'),
#             data = list(N = dim(data)[1],
#                         dbh = data$dbhest/max(data$dbhest),
#                         Pr = data$probed_rotten,
#                         Vf = data$Vbo),
#             chains = 1)
# save(fit, file = file.path(mpath, 'N.Rdata'))
load(file.path(mpath, 'N.Rdata'))
g <- fitgraph(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab['N',], collapse = ': ')`

### Model Predictions.
```{r N pred}
pars <- as.matrix(fit)[which.max(as.matrix(fit)[,'lp__']),c('beta', 'rho', 'sigma')]
Vf <- function(dbh, dbhmax, Pr, pars){
  mu <- (pars[1]*(dbh/dbhmax)*(dbh/dbhmax))*(1-Pr*pars[2])
  rlnorm(1, log(mu), pars[3])
}
pred <- apply(as.matrix(fit), 1, function(x)
  sapply(seq_len(dim(data2)[1]), function(i)
    Vf(data2$dbhest[i], dbhmax, data2$probed_rotten[i], c(x['beta'], x['rho'], x['sigma']))
  ))
pred <- data.frame(t(apply(pred, 1, function(x) quantile(x, probs = c(0.05, 0.95)))))
names(pred) <- c('5%', '95%')
pred$mean <- (pars[1]*(data2$dbhest/dbhmax)*(data2$dbhest/dbhmax))*(1-data2$probed_rotten*pars[2])
pred$dbh <- data2$dbhest
ggplot(data2, aes(x = dbhest, y = Vbo)) +
  geom_ribbon(aes(x = pred$dbh, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
  geom_line(aes(x = pred$dbh, y = pred$`5%`, color = '5%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$`95%`, color = '95%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$mean, color = 'mean'), linetype = 2) +
  geom_point() + geom_jitter() +
  theme_bw() +
  xlab('Estimated dbh (cm)') +
  ylab('Final softwood product (m3)') +
  scale_color_manual(name = 'Model',
                     values = c('5%' = 'black',
                                '95%' = 'black',
                                'mean' = 'red'))
```

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r C}
g$c
```

Convergence {data-width=300} 
-------------------------------------

> $P_{rotten} = (`r round(pars[1],3)`*dbh^2)*[1-Pr*`r round(pars[2],3)`]$

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r R}
g$r
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r P}
g$p
```

`r mtab['Np',1]`
==================

```{r Np, include=FALSE}
# fit <- stan(file = file.path(mpath, 'Np.stan'),
#             data = list(N = dim(data)[1],
#                         dbh = data$dbhest/max(data$dbhest),
#                         Pr = data$probed_rotten,
#                         Vf = data$Vbo,
#                         P = length(levels(as.factor(data$plot))),
#                         plot = as.integer(as.factor(data$plot))),
#             chains = 1)
# save(fit, file = file.path(mpath, 'Np.Rdata'))
load(file.path(mpath, 'Np.Rdata'))
g <- fitgraph(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab['Np',], collapse = ': ')`

### Model Predictions.
```{r Np pred}
pars <- as.matrix(fit)[which.max(as.matrix(fit)[,'lp__']),c('beta', 'rho', 'sigma')]
Vf <- function(dbh, dbhmax, Pr, pars){
  mu <- (pars[1]*(dbh/dbhmax)*(dbh/dbhmax))*(1-Pr*pars[2])
  rlnorm(1, log(mu), pars[3])
}
pred <- apply(as.matrix(fit), 1, function(x)
  sapply(seq_len(dim(data2)[1]), function(i)
    Vf(data2$dbhest[i], dbhmax, data2$probed_rotten[i], c(x['beta'], x['rho'], x['sigma']))
  ))
pred <- data.frame(t(apply(pred, 1, function(x) quantile(x, probs = c(0.05, 0.95)))))
names(pred) <- c('5%', '95%')
pred$mean <- (pars[1]*(data2$dbhest/dbhmax)*(data2$dbhest/dbhmax))*(1-data2$probed_rotten*pars[2])
pred$dbh <- data2$dbhest
ggplot(data2, aes(x = dbhest, y = Vbo)) +
  geom_ribbon(aes(x = pred$dbh, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
  geom_line(aes(x = pred$dbh, y = pred$`5%`, color = '5%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$`95%`, color = '95%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$mean, color = 'mean'), linetype = 2) +
  geom_point() + geom_jitter() +
  theme_bw() +
  xlab('Estimated dbh (cm)') +
  ylab('Final softwood product (m3)') +
  scale_color_manual(name = 'Model',
                     values = c('5%' = 'black',
                                '95%' = 'black',
                                'mean' = 'red'))
```

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r Cp}
g$c
```

Convergence {data-width=300} 
-------------------------------------

> $P_{rotten} = (`r round(pars[1],3)`*dbh^2)*[1-Pr*`r round(pars[2],3)`]$

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r Rp}
g$r
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r Pp}
g$p
```

`r mtab['Ns',1]`
==================

```{r Ns, include=FALSE}
# fit <- stan(file = file.path(mpath, 'Ns.stan'),
#             data = list(N = dim(data)[1],
#                         dbh = data$dbhest/max(data$dbhest),
#                         Pr = data$probed_rotten,
#                         Vf = data$Vbo,
#                         S = length(levels(as.factor(data$species))),
#                         species = as.integer(as.factor(data$species))),
#             chains = 1)
# save(fit, file = file.path(mpath, 'Ns.Rdata'))
load(file.path(mpath, 'Ns.Rdata'))
g <- fitgraph(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab['Ns',], collapse = ': ')`

### Model Predictions.
```{r Ns pred}
pars <- as.matrix(fit)[which.max(as.matrix(fit)[,'lp__']),c('beta', 'rho', 'sigma')]
Vf <- function(dbh, dbhmax, Pr, pars){
  mu <- (pars[1]*(dbh/dbhmax)*(dbh/dbhmax))*(1-Pr*pars[2])
  rlnorm(1, log(mu), pars[3])
}
pred <- apply(as.matrix(fit), 1, function(x)
  sapply(seq_len(dim(data2)[1]), function(i)
    Vf(data2$dbhest[i], dbhmax, data2$probed_rotten[i], c(x['beta'], x['rho'], x['sigma']))
  ))
pred <- data.frame(t(apply(pred, 1, function(x) quantile(x, probs = c(0.05, 0.95)))))
names(pred) <- c('5%', '95%')
pred$mean <- (pars[1]*(data2$dbhest/dbhmax)*(data2$dbhest/dbhmax))*(1-data2$probed_rotten*pars[2])
pred$dbh <- data2$dbhest
ggplot(data2, aes(x = dbhest, y = Vbo)) +
  geom_ribbon(aes(x = pred$dbh, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
  geom_line(aes(x = pred$dbh, y = pred$`5%`, color = '5%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$`95%`, color = '95%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$mean, color = 'mean'), linetype = 2) +
  geom_point() + geom_jitter() +
  theme_bw() +
  xlab('Estimated dbh (cm)') +
  ylab('Final softwood product (m3)') +
  scale_color_manual(name = 'Model',
                     values = c('5%' = 'black',
                                '95%' = 'black',
                                'mean' = 'red'))
```

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r Cs}
g$c
```

Convergence {data-width=300} 
-------------------------------------

> $P_{rotten} = (`r round(pars[1],3)`*dbh^2)*[1-Pr*`r round(pars[2],3)`]$

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r Rs}
g$r
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r Ps}
g$p
```

`r mtab['Nps',1]`
==================

```{r Nps, include=FALSE}
# fit <- stan(file = file.path(mpath, 'Nps.stan'),
#             data = list(N = dim(data)[1],
#                         dbh = data$dbhest/max(data$dbhest),
#                         Pr = data$probed_rotten,
#                         Vf = data$Vbo,
#                         P = length(levels(as.factor(data$plot))),
#                         plot = as.integer(as.factor(data$plot)),
#                         S = length(levels(as.factor(data$species))),
#                         species = as.integer(as.factor(data$species))),
#             chains = 1)
# save(fit, file = file.path(mpath, 'Nps.Rdata'))
load(file.path(mpath, 'Nps.Rdata'))
g <- fitgraph(fit)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab['Nps',], collapse = ': ')`

### Model Predictions.
```{r Nps pred}
pars <- as.matrix(fit)[which.max(as.matrix(fit)[,'lp__']),c('beta', 'rho', 'sigma')]
Vf <- function(dbh, dbhmax, Pr, pars){
  mu <- (pars[1]*(dbh/dbhmax)*(dbh/dbhmax) + 1)*(1-Pr*pars[2])
  rlnorm(1, log(mu), pars[3])
}
pred <- apply(as.matrix(fit), 1, function(x)
  sapply(seq_len(dim(data2)[1]), function(i)
    Vf(data2$dbhest[i], dbhmax, data2$probed_rotten[i], c(x['beta'], x['rho'], x['sigma']))
  ))
pred <- data.frame(t(apply(pred, 1, function(x) quantile(x, probs = c(0.05, 0.95)))))
names(pred) <- c('5%', '95%')
pred$mean <- (pars[1]*(data2$dbhest/dbhmax)*(data2$dbhest/dbhmax) + 1)*(1-data2$probed_rotten*pars[2])
pred$dbh <- data2$dbhest
ggplot(data2, aes(x = dbhest, y = Vbo)) +
  geom_ribbon(aes(x = pred$dbh, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
  geom_line(aes(x = pred$dbh, y = pred$`5%`, color = '5%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$`95%`, color = '95%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$mean, color = 'mean'), linetype = 2) +
  geom_point() + geom_jitter() +
  theme_bw() +
  xlab('Estimated dbh (cm)') +
  ylab('Final softwood product (m3)') +
  scale_color_manual(name = 'Model',
                     values = c('5%' = 'black',
                                '95%' = 'black',
                                'mean' = 'red'))
```

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r Cps}
g$c
```

Convergence {data-width=300}
-------------------------------------

> $P_{rotten} = (`r round(pars[1],3)`*dbh^2 + 1)*[1-Pr*`r round(pars[2],3)`]$

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r Rps}
g$r
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r Pps}
g$p
```

Conclusion 1
==================

> Adding random effect for plot and/or species ($\beta_p$, $\beta_s$) increased likelihood and decreased model variance ($\sigma$). Consequently best model is $N_{p,s}$. Stille we can try to improve this model by adding random effect for species and/or plot to the hyperparameter $\rho$.

Table 3: Models summary.
```{r mtab2}
mtab2 <- data.frame(
  L = c('$L$', '$L_{p}$', '$L_{s}$', '$L_{p,s}$'),
  Model = c(
    "$\\rho \\sim \\mathcal{logN} (log[\\theta_1 + \\theta2*dbh^2], \\sigma_2)$",
    "$\\rho \\sim \\mathcal{logN} (log[\\theta_1 + \\theta_p + \\theta2*dbh^2], \\sigma_2)$",
    "$\\rho \\sim \\mathcal{logN} (log[\\theta_1 + \\theta_s + \\theta2*dbh^2], \\sigma_2)$",
    "$\\rho \\sim \\mathcal{logN} (log[\\theta_1 +  \\theta_p + \\theta_s + \\theta2*dbh^2], \\sigma_2)$"
    )
  )
mtab2$L <- as.character(mtab2$L)
mtab2$Model <- as.character(mtab2$Model)
row.names(mtab2) <- c('L', 'Lp', 'Ls', 'Lps')
kable(mtab2, row.names = F)
```

`r mtab2['L',1]`
==================

```{r L, include=FALSE}
# fit <- stan(file = file.path(mpath, 'L.stan'),
#             data = list(N = dim(data)[1],
#                         dbh = data$dbhest/max(data$dbhest),
#                         Pr = data$probed_rotten,
#                         Vf = data$Vbo,
#                         P = length(levels(as.factor(data$plot))),
#                         plot = as.integer(as.factor(data$plot)),
#                         S = length(levels(as.factor(data$species))),
#                         species = as.integer(as.factor(data$species))),
#             chains = 1)
# save(fit, file = file.path(mpath, 'L.Rdata'))
load(file.path(mpath, 'L.Rdata'))
g <- fitgraph(fit, rho = F)
```

Model {data-width=300}
-------------------------------------

> `r paste(mtab['L',], collapse = ': ')`

### Model Predictions.
```{r L pred}
pars <- as.matrix(fit)[which.max(as.matrix(fit)[,'lp__']),c('beta', 'sigma', 'sigma_r')]
Vf <- function(dbh, dbhmax, Pr, pars){
  rho <- rlnorm(1, log(0.25), pars[3])
  mu <- (pars[1]*(dbh/dbhmax)*(dbh/dbhmax))*(1-Pr*rho)
  rlnorm(1, log(mu), pars[2])
}
pred <- apply(as.matrix(fit), 1, function(x)
  sapply(seq_len(dim(data2)[1]), function(i)
    Vf(data2$dbhest[i], dbhmax, data2$probed_rotten[i], c(x['beta'], x['sigma'], x['sigma_r']))
  ))
pred <- data.frame(t(apply(pred, 1, function(x) quantile(x, probs = c(0.05, 0.95), na.rm = T))))
names(pred) <- c('5%', '95%')
pred$mean <- (pars[1]*(data2$dbhest/dbhmax)*(data2$dbhest/dbhmax))*(1-data2$probed_rotten*0.25)
pred$dbh <- data2$dbhest
ggplot(data2, aes(x = dbhest, y = Vbo)) +
  geom_ribbon(aes(x = pred$dbh, ymin = pred$`5%`, ymax = pred$`95%`), color = 'grey', alpha = 0.2) +
  geom_line(aes(x = pred$dbh, y = pred$`5%`, color = '5%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$`95%`, color = '95%'), linetype = 2) +
  geom_line(aes(x = pred$dbh, y = pred$mean, color = 'mean'), linetype = 2) +
  geom_point() + geom_jitter() +
  theme_bw() +
  xlab('Estimated dbh (cm)') +
  ylab('Final softwood product (m3)') +
  scale_color_manual(name = 'Model',
                     values = c('5%' = 'black',
                                '95%' = 'black',
                                'mean' = 'red'))
```

### Parameters markov chains. *Light grey area represents warmup iterations.*
```{r CL}
g$c
```

Convergence {data-width=300}
-------------------------------------

> $P_{rotten} = (`r round(pars[1],3)`*dbh^2)*[1-Pr*`r round(pars[2],3)`]$

### Parameters posterior ditribution. *Light blue area represents 80% confidence interval, and vertical blue line the mean.*
```{r RL}
g$r
```

### Parameters pairs plot. *Parameters density distribution, pairs plot and Pearson's coefficient of correlation.*
```{r PL}
g$p
```


References
==================

