---
title: "Sylviculture modelling"
author: "Sylvain Schmitt sylvain.schmitt@agroparistech.fr"
date: '`r Sys.Date()`'
output:
  html_document:
    theme: journal
    toc: yes
    toc_depth: 5
    toc_float: yes
  pdf_document: default
  word_document: default
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
---

```{r config, message=FALSE, warning=FALSE, include=FALSE}
rm(list = ls()) ; invisible(gc())
library(knitr)
library(parallel)
library(TROLL)
library(RconTroll)
library(ggplot2)
library(cowplot)
library(plotly)
cores <- 15
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 8, fig.width = 8,
    cache = T, cache.lazy = F)
```

# Introduction

In order to simulate sylviculture with TROLL we need to implement a new sylviculture module inside TROLL model code. A first litterature review was completed by an interview with Laurent Descroix of the Office Nationale des Forêts. This document presents results of both the review and the interview.

This document focuses explicitly on sylviculture as it is realized in french guiana. In this context sylviculture can be narrow to selective logging (besides we will address other questions). Selective logging can be splitted in two parts: **designation** and **harvesting**. Both **designation** and **harvesting** encompass different sylviculture process and effects :

- Trees choice
    - *Harvestable areas*
    - Designation
    - Selection
    - Rotten
- Harvesting
    - Felling
    - Main track
    - Secondary track (cloisonnement)
    - Skidding
    - Other damages

We can model all this process and effects in two ways:

- **Explicitly** by modelling the process *(for well known process or deterministic events)*
- **Implicitly** by taking only into account the result of the processes *(e.g. a local increased mortality)*

All processes detailed after are splitted in two parts: 

- **Reality** explaining what is currently done in french Guiana 
- **Model** explaining how it is model model in TROLL code (giving the algorithm) and suggesting modifications

New code for this module is available [online](https://github.com/sylvainschmitt/TROLL/blob/master/inst/tools/main_2.3.1.cpp) (take care it is a work in progress).

# Trees choice

Before logging we first need to designate and select trees which will be harvested inside simulations.

## Harvestable areas

### Reality

First, havrestable areas are defined out of lowland areas and in the remainder by keeping all areas with a slope lower than 22 percent. A buffer of 30 meters is added to all harvestable areas representing engine capacity to extract wood with cables. Note that hazards like climate (dry or drought) can reduce or increase capacity of engine to explore a given area. In case of need bulldozer can be used to go in steeper slopes and grading can be realized to join harvestable areas.

### Model

One major limit of current implementation of TROLL model is that it assumes a flat environment. Consequently the whole simulated area inside TROLL can be considered has an harvestable zone. It conequently simplifies this first part but we need to keep in mind this major assumption in subsequent analysis.

## Designation

### Reality

Trees are then designated directly in the field in three categories: reserve trees for individuals with an ecological interest, future trees for individuals which can be harvested in the next cycles, and harvestable trees which will be sold for harvesting in current cycle. Harvestable trees are designated according to their species and maximum and minimum harvestable diameter associated to the species (detailed available in sylviculture guide). Total basal area of designated trees is then computed and aims 25 $m^3.ha^{-1}$ to be harvested. But because 20-30 percent of designated trees are considered as rotten once probed by the lumberman, total harvestable volume aims 30 $m^3.ha^{-1}$. Finally it happens that there is more or less than 30 $m^3.ha^{-1}$ of designated trees. If there is fewer it will be sold in this state, if there is more the minimum harvestable diameter is increased. The global idea is to gain maximum profit without exceding 25% of aboveground biomass (AGB) disturbance. Last but not least, this direct designation on the field before harvesting does not seems to result in aggregated extraction.

### Model

The harvestable area is the whole simulated forest. We needed to integrate an external file with all harvestable species precising their minimum and maximum harvestable diameter (following the sylviculture guide). We added to this sylviculture parameter file all parameters related to sylviculture or disturbance module (see code 1).

```{bash par, eval=FALSE, echo=TRUE}
##########################################################	
###  Sylviculture parameter file for the TROLL program ###	
##########################################################
###	GENERAL PARAMETERS
1	/* disturb_iter # iteration step where the disturbation occure */
###	disturbance
0.4	/* disturb_intensity # intensity of disturbance in percent of BA */
###	logging
30	/* designated_volume # volume designated for harvesting in m3/ha */
25	/* harvested_volume # volume harvested in m3/ha */
25	/* numespharvestable # number of harvestable species */	

###	Species
****	spnum	dbhmin	dbhmax	interest
Brosimum_guianense	7	0.55	2.0	1
Brosimum_rubescens	8	0.55	2.0	1
Caryocar_glabrum	12	0.55	2.0	1
Dicorynia_guianensis	35	0.55	2.0	1
Goupia_glabra	53	0.55	2.0	1
Manilkara_bidentata	81	0.55	2.0	1
Manilkara_huberi	82	0.55	2.0	1
Ocotea_argyrophylla	94	0.55	2.0	1
Qualea_rosea	130	0.55	2.0	1
Ruizterania_albiflora	134	0.55	2.0	1
Vouacapoua_americana	161	0.55	0.70	1
Couma_guianensis	29	0.55	2.0	2
Eperua_grandiflora	42	0.55	2.0	2
Lecythis_zabucajo	71	0.55	2.0	2
Moronobea_coccinea	90	0.55	2.0	2
Rhodostemonodaphne_grandis	133	0.55	2.0	2
Sterculia_pruriens	140	0.55	2.0	2
Sterculia_speciosa	141	0.55	2.0	2
Sterculia_villifera	142	0.55	2.0	2
Virola_michelii	159	0.55	2.0	2
Vochysia_guianensis	160	0.55	2.0	2
Bocoa_prouacensis	6	0.55	2.0	3
Couratari_multiflora	30	0.55	2.0	3
Eperua_falcata	41	0.55	2.0	3
Eperua_rubiginosa	43	0.55	2.0	3
```

Code 1: Example of Sylviculture parameter file for the TROLL program.

Following those data the model can calculate the total harvestable volume ${V_h}_{tot}$ and retains all trees id as **can be designated**. If ${V_h}_{tot} < 30*n_{ha}$, then all **can be designated** tree are considered as **designated**. If ${V_h}_{tot} > 30*n_{ha}$, then minimum harvestable diameter $dbh_{min}$ is increased untill ${V_h}_{tot} < 30*n_{ha}$, and finally all **can be designated** tree are considered as **designated** (see code 2).

```{rcpp designation, eval=FALSE, echo=TRUE}
void Designate() {

	int site, col, row, sp, sph=0, designated;
	float volume, dbh_min[numespharvestable], min_dbh_min, max_dbh_max=0.0;

	/* getting species vector of minimum harvestable diameter */
	for(sp=1;sp<=numesp;sp++)
		if(S[sp].s_harvestable){
			dbh_min[sph]=S[sp].s_dbhmin; 
			sph++;
			if(S[sp].s_dbhmax > max_dbh_max)
				max_dbh_max = S[sp].s_dbhmax;
		}

	/* getting minimum value of minimum harvestable diameter among species*/
	min_dbh_min = dbh_min[0];
	for(sph=1;sph<numespharvestable;sph++)
		if(dbh_min[sph] < min_dbh_min)
			min_dbh_min = dbh_min[sph];

	/* designating tree, increasing minimum harvestable dbh if needed to br under the objective */
	for(min_dbh_min; min_dbh_min < max_dbh_max; min_dbh_min += 0.1){
		volume=0.0;
		designated=0;
		for(site=0;site<sites;site++){
        	if(T[site].t_age > 0										/*alive tree*/
        		&& S[T[site].t_sp_lab].s_harvestable 					/*harvestable species*/
        		&& T[site].t_dbh >= S[T[site].t_sp_lab].s_dbhmin		/*reached minimum dbh*/
        		&& T[site].t_dbh <= S[T[site].t_sp_lab].s_dbhmax){		/*under maximum dbh*/
        		Tlogging[0][site] = 1;
        		volume += -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/
        		designated++;
        	}
        }
        if(volume < designated_volume)
        	break;														/*if the volume is under the objective we can stop */
        else
        	for(sp=1;sp<=numesp;sp++)
        		if(S[sp].s_harvestable)
        			S[sp].s_dbhmin += 0.01;								/*if the volume is greater than the objective we need to derease minimum harvestable diameter for all species */
	}

	cout << designated << " trees have been designated, representing " << volume << " m3." << endl;
    cout << "dbh min is now " << min_dbh_min << endl;
}
```

Code 2: Designation module.

## Selection

### Reality

Because the harvesters are focusing on few species with easier marketable wood for the moment (Angélique, Gonfolo, Grignon franc, Balata and few rares), about only 20 $m^3.ha^{-1}$ are harvested, and sometimes less, especially in the West forests of French Guiana. In addition to that, few rules are added for some species when designating trees (e.g. protecting no more than one Angélique and Gonfolo every 100 meters for seeding and only one Bagasse for two).

### Model

Thereafter we need to split **designated** trees between **selected** and **designated but not selected**. **Designated** trees kept by the harvester are linked to an additional data representing the species interest in external file (see code 1). Each harvestable species is ranked on its economic value. Then the model will kept only 25 $m^3.ha^{-1}$ inside designated trees by keeping only higher rank species.

```{rcpp selection, eval=FALSE, echo=TRUE}
void Select() {
	
	int site, sp, i, rank, rankmax=0, unselected=0;
	float volume=0.0;

	/* Calculating designated volume */
	for(site=0;site<sites;site++) 
		if(Tlogging[0][site] == 1)
			volume += -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/
    
	if(volume <= harvested_volume)
        cout << "All designated trees will be harvested." << endl;

	if(volume > harvested_volume){

		/* determining maximal interest rank (leat valuable species) */
		for(sp=1;sp<=numesp;sp++)
        	if(S[sp].s_interest > rankmax)
        		rankmax = S[sp].s_interest;	

        /* determining determining headcount for each rank */
        int rank_nb[rankmax];
        for(rank=0;rank<rankmax;rank++) rank_nb[rank]=0;
        for(site=0;site<sites;site++)
        	if(S[sp].s_harvestable)
        		rank_nb[S[T[site].t_sp_lab].s_interest]++;

        /* removing tree untill wanted volume is reached starting by highest rank */
        for(rank=rankmax-1;rank>=0;rank--){
        	while(rank_nb[rank]>0){
        		site=floor(genrand2()*sites);
        		if(Tlogging[0][site]==1 && S[T[site].t_sp_lab].s_interest==rank){
        			Tlogging[0][site]=0;
        			rank_nb[rank]--;
        			unselected++;
        			volume -= -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/
        			if(volume <= harvested_volume) break;
        		}
        	}
        	if(volume <= harvested_volume) break;
        }

        cout << unselected << " trees have been unselected, volume is now of " << volume << " m3." << endl;
	}
}
```

Code 3: Selection module.

## Rotten

### Reality

20-30 percent of designated trees are considered as rotten once probed by the lumberman.

*NB: In fact only 50 percent of designated trees considered as rotten once probed by the lumber would be really entirely rotten. 50% of theim would be vital on 90% of the volume. Moreover if fuelwood economy is developped rotten tree could be used and the risk to cut a rotten tree could be taken (especially if 50% of theim are actually harvestable). But this fact only represent a perspective for the moment.*

### Model

Actually rotten trees are not random. We used rotten inventories from ONF to realize a model predictiong rotten trees volume from their species and diameter. First we seeked a model M to predict tree probability to be probed as rotten (see [probability to be rotten](rotten2.html)). Secondly we seeked a model N to predict final volume of wood in tree probed as rotten (see [final volume of wood](rotten3.html)). All results are summarised in [rotten document](rotten.html). Finally we implemented the model M: 
$$P_{rotten} = inv_{logit}(-5.151 + 0.042*dbh_{(cm)})$$
inside the `SelectiveLogging` module of TROLL model.

```{rcpp rotten, eval=FALSE, echo=TRUE}
void Rot() {

	int site, rotten=0;
	float protten, volume=0.0;

	/* Calculating selected volume */
	for(site=0;site<sites;site++) 
		if(Tlogging[0][site] == 1)
			volume += -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/

	/* evaluates each tree probability to be rotten, and remove it if randomly in the risk to be rotten*/
    for(site=0;site<sites;site++){
       	if(Tlogging[0][site]==1){
       		protten = 1 / (1 + exp(-(-5.151 + 0.042*T[site].t_dbh*100))); /*Probability to be rotten*/
       		if(genrand2() < protten){
       			Tlogging[0][site]=0;
       			rotten++;
           		volume -= -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/
       		}
       	}
       } 
    cout << rotten << " trees are rotten, volume is now of " << volume << " m3." << endl;
}
```

Code 4: Rotten module.

# Harvesting

Once designated we can proceed to logging and associated damages.

## Felling

### Reality

Main issue around the logging will be treefall direction. Due to crown aspects treefall is often considered as random. Whereas difficult to manage, treefall can still be oriented. In fact 4 orientations are available for treefall when logging (see figure 1). Oriented treefall idea is to get logs oriented at 45° two skidding ways to reduce damages when skidding. Currently few harvesters are applying this practice which is to be developed.

![figure 1. Treefall orientations when logging](treefall.png)

### Model

Whereas interessant to test, due to the fact it is not much applied in french guiana, I think we should not model oriented logging for the moment. We should consider logging treefall as random like current treefall implementation inside TROLL (see code 5).

```{rcpp felling, eval=FALSE, echo=TRUE}
void Fell() {

	int site, row, col, felled=0;
	float volume=0.0;

	/* fell the selected tree not rotten */
    for(site=0;site<sites;site++){
        if(Tlogging[0][site]==1){
        	row = floor(site/cols);
        	col = site-(row*cols);
        	volume += -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/
        	output[36] << "L" << "\t" << col << "\t" << row << "\t" << T[site].t_age << "\t" << T[site].t_dbh << "\t" << T[site].t_Tree_Height << "\t" << T[site].t_Crown_Radius << "\t" << T[site].t_Crown_Depth << "\t" << T[site].t_sp_lab << endl;
           	T[site].FellTree();
           	felled ++;
        }
    } 
    cout << felled << " trees have been felled representing " << volume << " m3." << endl;
}
```

Code 5: Felling module.

We added a specific felling function (in which we could implement in future versions oriented logging) to simulate fellinf in the module loop (see code 6).

```{rcpp FellTree, eval=FALSE, echo=TRUE}
void Tree::FellTree() {
  
  float t_angle = float(twoPi*genrand2()); // random angle
  float h_true = t_Tree_Height*LV;
  int xx, yy, row0, col0, r_int, h_int=int(h_true*NH);    
  
  if(t_dbh*LH>0.1) nbTreefall10++;
  Thurt[0][t_site+sites] = int(t_Tree_Height); // Thurt[0] saves the integer tree height, here exactly at the place where the tree fell...
  Tlogging[2][t_site] = 1;
  row0=t_site/cols;       /* fallen stem destructs other trees */
	col0=t_site%cols;
	for(int h=1;h<h_int;h++) { // loop on the fallen stem (horizontally)
	  xx=int(flor(col0+h*cos(t_angle))); // get projection in col (= xx) direction, where xx is absolute location
	  if(xx<cols){
	    yy=int(row0+h*sin(t_angle)); // get projection in row (= yy) direction, where yy is absolute location
	    Thurt[0][xx+(yy+rows)*cols] = int(t_Tree_Height); // Thurt[0] where the stem fell, calculation: xx+(yy+rows)*cols= xx + yy*cols + rows*cols = xx + yy*cols + sites
	    if(xx<cols && yy<rows) Tlogging[2][xx+yy*cols] = 1; // Tfell[0] is used to represent gaps for gaps damages modelling
	  }
	}
	xx=col0+int((h_true*NH-t_Crown_Radius)*cos(t_angle)); // where crown ends/starts fallen crown destructs other trees */
	yy=row0+int((h_true*NH-t_Crown_Radius)*sin(t_angle));
	r_int = int(t_Crown_Radius);
	for(int col=max(0,xx-r_int);col<min(cols,xx+r_int+1);col++) { /* loop on the fallen crown (horizontally) */
	for(int row=yy-r_int;row<yy+r_int+1;row++) {
	  if((col-xx)*(col-xx)+(row-yy)*(row-yy)<r_int*r_int) {
	    Thurt[0][col+(row+rows)*cols] = int((t_Tree_Height-t_Crown_Radius*NV*LH)*0.5);
	    if(xx<cols && yy<rows) Tlogging[2][xx+yy*cols] = 1;
	  }
	}
	}
	Death();
}
```

Code 6: Felling module.

## Main track

### Reality

Roads are split in three classes: truck roads, main tractor track, and secondary track ('cloisonement'). Main skidtrails are used by skidding engines and follow crest model ; a function can calculate in advance their volume of transit by summing all pixels they serve and assuming 20 $m^3.ha^{-1}$. 

### Model

One more time, one major assumption of TROLL is a flat environment. Consequently the main track can be considered as a way starting from the middle of one side of the simulated forest and reaching the center (see code 7).

```{rcpp MT, eval=FALSE, echo=TRUE}
void MainTracks() {

    int site, row, col, individuals=0;
    float volume=0.0;
           
    for(row=0;row<(rows/2);row++){
        for(col=((cols/2)-3);col<((cols/2)+3);col++){
        	site = col+row*cols;
        	Tlogging[1][site] = 1;
        	if(T[site].t_age != 0) {
        		volume += -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/
        		output[36] << "MT" << "\t" << col << "\t" << row << "\t" << T[site].t_age << "\t" << T[site].t_dbh << "\t" << T[site].t_Tree_Height << "\t" << T[site].t_Crown_Radius << "\t" << T[site].t_Crown_Depth << "\t" << T[site].t_sp_lab << endl;
            	T[site].Death();
            	individuals++;
        	}
       	}
    }    
    cout << individuals << " trees have been killed for the main track representing " << volume << " m3." << endl;
}
```

Code 7: Main track module.

## Secondary tracks (cloisonnement)

### Reality

Secondary tracks are computed once trees have been designated and the geolocation taken. Secondary track are all at a maximum distance of 30 meters from designated trees (because engine cables reach 50 meters but with an angle of 45°). Last thing taken into account is secondary track slope between track border ('devers') ; it need to be under 4%. Secondary tracks draw is half automatic but currently user is drawing the final pattern.

### Model

To not over-complicate the model we decided to simulate secondary tracks with few simple rules for a full automatic integration. It will not correspond to reality but because secondary tracks draw is a vast question (e.g. piste 2 and 3 softwares), it will answer or needs. The secondary tracks module compute the following algorithm (see code 8 and figure 2):

- Calculate a loads map measuring every trees at a distance of 30 meters for each pixel
- Calculate a track proximity maps of the closest existing track
- Select the pixel with the highest load and closest track
- Find the closest existing track and join it
- Trace the secondary track removing from list all felt trees in a radius of 30 meters from the track
- Repeat operations untill no felt trees are left

```{rcpp ST, eval=FALSE, echo=TRUE}
void SecondaryTracks() {

	    int load[sites], tracks[sites], individuals=0, felt=0;
        int site, col, row, site0, row0, col0, siteT, rowT, colT;
        float d, d0, volume=0.0;

        /* Counting number of felt trees to skid */
        for(site=0;site<sites;site++) felt += Tlogging[0][site];
        
        while(felt > 0){

        	/*Computing loadings and tracks distance for each tree*/
        	for(site0=0;site0<sites;site0++){ 
        		load[site0]=0;
        		tracks[site0]=rows*rows + cols*cols;
        		row0 = floor(site0/cols);
        		col0 = site0-(row0*cols);
        		for(site=0;site<sites;site++){
        			if(Tlogging[0][site]==1 || Tlogging[1][site]==1){ // compute distance if the site is a felt tree or a track
        				row = floor(site/cols);
        				col = site-(row*cols);
        				d = (row - row0)*(row - row0) + (col - col0)*(col - col0);
        				if(Tlogging[0][site]==1 && d <= (30*30)) // site can evacuate the tree if is at a distance smaller than 30 meters
        					load[site0]++;
        				if(Tlogging[1][site]==1 && d < tracks[site0]) // save the track distance if it's closest than the previously saved one
        					tracks[site0]=d;
        			}
        		}
        	}

        	/*Seeking the best place to start the secondary track*/
        	site0=0;
        	for(site=0;site<sites;site++){
        		if(load[site]>load[site0]) // best candidate is the one which can evacuate maximum number of trees
        			site0=site;
        		if(load[site]==load[site0] && tracks[site]<tracks[site0]) // for equal loadings, best candidate is the one with a minimum distance to join an existing track
        			site0=site;
        	}	

        	/*Seeking for the closest track*/
        	row0 = floor(site0/cols);
        	col0 = site0-(row0*cols);
        	d0 = rows*rows+cols*cols;
        	for(site=0;site<sites;site++){
        		if(Tlogging[1][site]==1){ // if it's a track compute distance to the track
        			rowT = floor(site/cols);
        			colT = site-(rowT*cols);
        			d = (row0 - rowT)*(row0 - rowT) + (col0 - colT)*(col0 - colT);
        			if(d<d0){ // if the track is closer than the previously saved one, keep the location
        				siteT=site;
        				d0=d;
        			}
        		}
        	}

        	/*Trace the secondary track*/
        	rowT = floor(siteT/cols);
        	colT = siteT-(rowT*cols);
        	do{
        		do {
            		for(int i=-2;i<=2;i++){ 
        				for(int j=-2;j<=2;j++){
        					site = (col0+i)+(row0+j)*cols;
        					if(site>=0 && site<sites) Tlogging[1][site]=1; //flag the track with a size of 4 meters
        				}
        			}
        			for(site=0;site<sites;site++){ 
        				if(Tlogging[0][site]==1){
        					row = floor(site/cols);
        					col = site-(row*cols);
        					d = (row - row0)*(row - row0) + (col - col0)*(col - col0);
        					if(d <= (33*33)){ //unflag served trees in a radius of 30 meters
        						Tlogging[0][site]=0;
        						felt--;
        					}
        				}
        			}
        			if(col0 > colT) col0--; //move in direction of the closest existing track
        			if(col0 < colT) col0++;
        			if(row0 > rowT) row0--;
        			if(row0 < rowT) row0++;
        		} while(row0 != rowT); //stop when we reach the closest existing track
        	} while(col0 != colT);
        	cout << "A secondary track have been traced, " << felt << " trees still need to be evacuated." << endl; //!LONG! computation, console output to follow advancement
		}

		/* Removing trees on secondary tracks */
        for(site=0;site<sites;site++){ 
        	if(Tlogging[1][site] == 1 && T[site].t_age != 0){
        		row = (site/cols);
        		col = site-(row*cols);
        		volume += -0.0358 + 8.7634*T[site].t_dbh*T[site].t_dbh; /*volume by ONF-2011 in French Guiana - Center (Kourou)*/
        		output[36] << "ST" << "\t" << col << "\t" << row << "\t" << T[site].t_age << "\t" << T[site].t_dbh << "\t" << T[site].t_Tree_Height << "\t" << T[site].t_Crown_Radius << "\t" << T[site].t_Crown_Depth << "\t" << T[site].t_sp_lab << endl;
            	T[site].Death();
            	individuals ++;
        	}
        }
    cout << individuals << " trees have been killed for secondary tracks representing " << volume << " m3." << endl;
}
```

Code 8: Secondary tracks module.

```{r tracks}
test <- loadOutput('test', '~/Documents/ECOFOG/TROLL/inst/tools/test/')
dist <- test@disturbance
g <- ggplot(dist, aes(x = col, y = row, size = dbh, col = type, label = species)) + geom_point() + coord_fixed()
g
```

Figure 2. Tracks design inside TROLL.

## Other damages

### Reality

The Office Nationale des Forêts is realizing diagnostic of disturbance from harvesting (DPE). The question of increased mortality is also studied with GUYAFOR and TmFO plots. First results suggests that the time for the ecosystem to come back to its original death rate depend on the original death rate intensity. But this time seems lower thant the 10 years often used in simulations [@Huth2004; @Khler2004; @Ruger2008]. Last thing increased mortality seems localised around harvested areas (but even for not directly hurted trees).

### Modelling

We gathered data from Paracou dataset in cenususes between 1988 and 1992 on Paracou harvested plots. Individuals were categorized between alive, dead, or recruited during the period. Individuals categorized as damaged tree (17), poisoned tree alive (19), death during logging standing (1), logged tree (4), poisoned tree (9), recruited alive or recruited and dead were removed from the dataset. Dead trees still in the dataset were then categorized in natural death standing (0), primary windfall (6), and secondary windfall (7). We adapted the model from **Cite Herault** based on a disturbance index into:
$$Death_i \sim \mathcal{B}(P(Death_i))$$
$$with ~~ P(Death_i) = logit^{-1}(\theta + \beta*e^{\alpha*d_{gaps}}) = \frac{e^{\theta + \beta*e^{\alpha*d_{gaps}}}}{1 + e^{\theta + \beta*e^{\alpha*d_{gaps}}}}$$
$Death$ of a tree $i$ follows a $\mathcal{Bernoulli}$ law of probability $P(Death_i)$. The odds for a tree $i$ to die $O(Death_i)$ is calculated by the sum of the natural tree death odd $\theta$ and a perturbation index $\beta*e^{\alpha*d_{gaps}}$. The perturbation index depend on the distance $d_{gaps}$ of the tree $i$ to the closest logging gap. The probability for a tree $i$ to die $P(Death_i)$ is finally calculated by taking the inverse logit of the odd $logit^{-1}[O(Death_i)]$ (see [hurt models](hurt.html) document).

We need now to transfer this allometry into TROLL to simulate disturbed trees that will die because of the selective logging gaps. A tree will die and fall if he randomly get under the probability to die because of the logging gap:
$$P(Death_i) < rand ~~with~~ rand \in [0,1]$$
But the probabilty to be dead $P(Death_i)$ for a tree $i$ encompass both the probability to die due to the logging and the natural death rate. So we need to remove the natural death rate to this probability ($P(Death_i) - DeathRate_i$). On the other hand, in the current implementation of TROLL a tree dies and falls because he has been injured. This process is simulated by the variable $hurt$. The probability to die follows formula:
$$Height < 2*hurt*rand ~~with~~ rand \in [0,1]$$
So we can increase the variable $hurt$ to increase probability to die for trees close to logging gaps with:
$$P(Death_i) - DeathRate_i = \frac{Height}{2*hurt}$$
$$hurt = \frac{Height}{2*P(Death_i) - DeathRate_i}=\frac{Height}{2*(logit^{-1}(\theta + \beta*e^{\alpha*d_{gaps}}) - DeathRate_i)}$$
$$hurt = \frac{Height}{2*[logit^{-1}(-4.441 + 0.762*e^{0.064*d_{gaps}}) - Species::DeathRate]}$$

Because the increased mortality due to gaps model was built on data for the 4 years after the logging, gaps damages are implemented in a submodule that get activated one year after the logging. It takes in account only trees that died hurted by tree felling (corrrection made following Isabelle mail).

```{rcpp damages, eval=FALSE, echo=TRUE}
void GapDamages() {

	cout << "###   Selective Logging Long Term Damages   ###" << endl;
	int site, row, col, siteG, rowG, colG;
    float deathrate, gaps_deathrate, gaps_hurt, d, dgaps[sites];

    /*Initialise dgaps to maximum distance to a gaps (null effect)*/
    for(site=0;site<sites;site++) dgaps[site] = rows*rows + cols*cols;

    /*Compute for each tree the distance to the closest gap*/
    for(siteG=0;siteG<sites;siteG++){
        if(Tlogging[2][siteG] == 1){
        	if(T[siteG].t_age > 1){ // New trees could have been recruited over a year
        		rowG = floor(siteG/cols);
				colG = siteG-(rowG*cols);
				for(site=0;site<sites;site++){
					row = floor(site/cols);
        			col = site-(row*cols);
         			d = (row - rowG)*(row - rowG) + (col - colG)*(col - colG);
         			if(d < dgaps[site])	dgaps[site] = d;
         		}
			}
		}
    }

    /*Hurt trees depending on their distance to a gaps following an allometry fitted with Paracou data*/
    for(site=0;site<sites;site++){
       	if(T[site].t_age != 0 && T[site].t_dbh > 0.1){ //tree with dbh<10 have not an increased mortality closed to gaps, on the contrary they'll have a tendency 
       		gaps_deathrate = -4.441 + 0.762*exp(0.064*sqrt(dgaps[site]));
       		gaps_deathrate = exp(gaps_deathrate) / (1 + exp(gaps_deathrate)); // Allometry representing gaps damages
       		deathrate = T[site].t_s->DeathRate(T[site].t_PPFD, T[site].t_dbh, T[site].t_NPPneg);
       		if(gaps_deathrate > deathrate){
       			gaps_hurt = T[site].t_Tree_Height/(2*(gaps_deathrate - deathrate));
       			T[site].t_hurt += gaps_hurt;
       		}
       	}
    }        
}
```

Code 9: Gap damages module.

# Conclusion

## Model

We can summarize modelling of selective logging in few steps :

- Trees choice
    - Harvestable areas: the whole simulated forest
    - Designation: all trees meeting species minimum and maximum harvestable diameters under or equal to a total volume of 30 $m^3.ha^{-1}$
    - Selection: first ranked trees according to harvesters reaching a total volume of 25 $m^3.ha^{-1}$
    - Rotten: tree are considered as rotten depending on their diameter following our allometry (see [rotten models](rotten2.html))
- Harvesting
    - Felling: all selected trees
    - Main track: from the middle of one side of the simulated forest to the center
    - Secondary track (cloisonnement): following our own simplified algorithm
    - Other damages: tree are hurted depending on their distance to a logging gap following our allometry (see [hurt models](hurt.html))
    
## Perspectives

Current slective logging in french guiana encompass different perspective to evolve. Some are summarized here:

- Diversification: harvesting more species (harvesters select species with higher economical interest) to reach 25 $m^3.ha^{-1}$
- Oriented treefall: see section about logging
- Logs length for skidding: see section about roads and skidding
- Thinning: remove trees to increase growth grom trees of interest
- Decreasing the maximum distance of skid trail from felled trees from 30 to 20 m, which will result in an increase in the skid trails network, in the fuelwood harvest and a decrease of the skidding costs

## Internship question

One major advantage of TROLL model compare to other simulators spatially-explicits and individual-based (e.g. FORMIND and SORTIE) is the use of species and not of plant functionnal types (PFT). In that way, TROLL outperform other simulators to simulates biodiversity and its related effects. This is the reason why I think I could use the implementation of the sylviculture module inside TROLL to study the perspective of diversification. 

*In which order reducing damages on global diversity by increasing harvesting diversity will affect forest ecosystem answer to the distruabnce brought by selective logging ?*

# References
